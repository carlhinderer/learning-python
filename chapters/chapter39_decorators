-------------------------------------------------
CHAPTER 39 - DECORATORS
-------------------------------------------------

- Decorators

    Decorators provide a way to insert automatically run code at the end of function
      and class definition statements.  The decorator approach is sometimes called
      'aspect-oriented programming' or 'annotation' in other languages.

    Function decorators install wrapper objects to intercept later function calls.

    Class decorators install wrapper objects to intercept later instance creation calls.



- Decorator Usage

    @decorator
    def F(arg):
       ...

    F(99)          # Calls decorator(F)(99)


    # Static method example
    class C:
        @staticmethod
        def meth(...): ...       # meth = staticmethod(meth)

    # Property example
    class C:
        @property
        def name(self): ...      # name = property(name)



- Function decorator Implementation

    def decorator(F):
        # Process function F
        return F

    @decorator
    def func(): ...


    # Wrapper example
    def decorator(F):                     # On @ decoration
        def wrapper(*args):               # On wrapped function call
            # Use F and args
            # F(*args) calls original function
            return wrapper

    @decorator                            # func = decorator(func)
    def func(x, y):                       # func is passed to decorator's F



- Class decorator implementation

    def decorator(C):
        # Process class C
        return C

    @decorator
    class C: ...


    # Wrapper example
    def decorator(cls):                             # On @ decoration
        class Wrapper:
            def __init__(self, *args):              # On instance creation
                self.wrapped = cls(*args)
            def __getattr__(self, name):            # On attribute fetch
                return getattr(self.wrapped, name)
        return Wrapper

    @decorator
    class C:                                        # C = decorator(C)
        def __init__(self, x, y):                   # Run by Wrapper.__init__
            self.attr = 'spam'


    >>> x = C(6, 7)                                 # Really calls Wrapper(6, 7)
    >>> print(x.attr)                               # Runs Wrapper.__getattr__, prints "spam"